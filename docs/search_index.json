[["tidyverse.html", "3 Using tidyverse 3.1 Installing tidyverse 3.2 Load tidyverse 3.3 Import Data 3.4 Data wrangling with dplyr package 3.5 forcats", " 3 Using tidyverse The tidyverse is a collection of R packages that many data analysts use. In this course, we will be heavily relying on a few of the packages such as readr, dplyr and ggplot2 that are in this collection. Instead of installing each package separately as we normally would, we can simply install tidyverse and that would install all the other packages that we want. 3.1 Installing tidyverse install.packages(&quot;tidyverse&quot;) Although we have installed tidyverse, we cannot use it unless we load it. To load it, we need the library() function. 3.2 Load tidyverse library(tidyverse) Note. You can temporarily load a package without using the library() function using the notation package::function. This tells R to load the package for this specific chunk of code and not for the entire session. This allows anyone who reads the code to know which package the function comes from. I typically dont do this because it can be quite tiresome to keep typing the name of the package over and over. However, package::function comes in especially handy when we want to help R distinguish between two packages with the same function names. For example, the packages ggplot2 and psych both have a function alpha(). R doesnt know which package to choose if you load both packages. So, to specify that you want to use the function from the psych package, you should type psych::alpha(). Now that we have tidyverse loaded, lets do stuff with it. Lets start with importing data. 3.3 Import Data Typically, R users do not have to enter their data into R directly. Instead, they already have their dataset in various formats, such as .csv, .txt, .sav, .xlsx, etc. So what they need to do is to import the dataset into R. In this class, I typically use .csv files. To import .csv files, we can use the read_csv() function from the readr package in tidyverse. The data set that I will use here is a hypothetical one I created. You can download it here: SWB.csv. data &lt;- read_csv(&quot;SWB.csv&quot;) # this code is saying... # read in the .csv file, &quot;SWB.csv&quot; and assign it to &quot;data&quot; # from now on, &quot;data&quot; will refer to the data in this csv file You may also use the built-in R function read.csv(). If you do so, you dont have to load the tidyverse package. read.csv() is supposedly slower than read_csv(), which in turn is slower than data.tables fread(). For our purposes, though, it really doesnt matter which you use, so long as you can successfully import the data file. data &lt;- read.csv(&quot;SWB.csv&quot;) If you have other file types, such as .txt, .sav, .xlsx, you might need different packages. For example, for excel files (.xlsx), you will need the readxl package. For SPSS (.sav), you will need the haven package or the foreign package. For this class, I wont use file types aside from .csv, but it is good to be aware of the packages to use if you want to import other file types. 3.3.1 Check Imported Dataset Before conducting any analyses, check that the dataset has been imported correctly. Go to the Environment pane (top right pane). Click data. The top left pane should show the imported data. Alternatively, you may type View(data) into the console. Rows: The data for each participant is recorded in a single row (e.g., data for Participant 1 is in Row 1) Columns: The data for each variable is recorded in a single column. Names of the variables are in the headers for each column Scroll down to ensure all rows have been imported correctly. There should be 343 rows. Scroll right to ensure all columns have been imported correctly. There should be 23 columns. Another way to check the imported dataset is using the str() or the glimpse() functions. Both give you roughly similar information (e.g., that there are 343 rows and 23 columns, the names of the variables) str(data) ## spec_tbl_df [343 x 23] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ pin : num [1:343] 1 2 3 4 5 6 7 8 9 10 ... ## $ gender : num [1:343] 0 1 1 1 1 0 1 0 1 0 ... ## $ marital_status: num [1:343] 1 1 3 1 2 1 2 1 2 1 ... ## $ have_children : num [1:343] 0 1 0 0 0 1 0 0 0 1 ... ## $ mvs_1 : num [1:343] 4 4 5 2 2 3 2 2 3 2 ... ## $ mvs_2 : num [1:343] 3 3 4 3 2 4 3 3 4 3 ... ## $ mvs_3 : num [1:343] 3 3 4 3 3 4 3 3 4 3 ... ## $ mvs_4 : num [1:343] 3 3 3 2 2 5 4 4 3 4 ... ## $ mvs_5 : num [1:343] 3 3 4 3 3 4 3 3 4 2 ... ## $ mvs_6 : num [1:343] 4 4 5 2 2 3 4 4 5 2 ... ## $ mvs_7 : num [1:343] 3 2 4 2 3 3 3 3 4 3 ... ## $ mvs_8 : num [1:343] 4 4 5 4 4 5 3 3 4 3 ... ## $ mvs_9 : num [1:343] 2 2 1 3 3 2 3 3 2 4 ... ## $ swb2019_1 : num [1:343] 3 4 3 5 4 4 2 3 4 4 ... ## $ swb2019_2 : num [1:343] 3 5 3 4 3 3 2 2 4 4 ... ## $ swb2019_3 : num [1:343] 4 4 3 5 3 3 3 2 4 4 ... ## $ swb2019_4 : num [1:343] 4 5 4 5 3 4 2 2 3 5 ... ## $ swb2019_5 : num [1:343] 3 5 4 4 4 3 2 2 4 5 ... ## $ swb2021_1 : num [1:343] 3 3 2 4 3 4 1 3 3 4 ... ## $ swb2021_2 : num [1:343] 3 5 2 4 2 3 1 2 3 4 ... ## $ swb2021_3 : num [1:343] 4 3 3 5 3 2 3 2 4 3 ... ## $ swb2021_4 : num [1:343] 4 4 4 5 3 3 2 2 3 4 ... ## $ swb2021_5 : num [1:343] 3 4 4 4 4 3 2 2 4 5 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. pin = col_double(), ## .. gender = col_double(), ## .. marital_status = col_double(), ## .. have_children = col_double(), ## .. mvs_1 = col_double(), ## .. mvs_2 = col_double(), ## .. mvs_3 = col_double(), ## .. mvs_4 = col_double(), ## .. mvs_5 = col_double(), ## .. mvs_6 = col_double(), ## .. mvs_7 = col_double(), ## .. mvs_8 = col_double(), ## .. mvs_9 = col_double(), ## .. swb2019_1 = col_double(), ## .. swb2019_2 = col_double(), ## .. swb2019_3 = col_double(), ## .. swb2019_4 = col_double(), ## .. swb2019_5 = col_double(), ## .. swb2021_1 = col_double(), ## .. swb2021_2 = col_double(), ## .. swb2021_3 = col_double(), ## .. swb2021_4 = col_double(), ## .. swb2021_5 = col_double() ## .. ) ## - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; glimpse(data) ## Rows: 343 ## Columns: 23 ## $ pin &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, ~ ## $ gender &lt;dbl&gt; 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0~ ## $ marital_status &lt;dbl&gt; 1, 1, 3, 1, 2, 1, 2, 1, 2, 1, 3, 2, 3, 3, 3, 1, 1, 1, 3~ ## $ have_children &lt;dbl&gt; 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0~ ## $ mvs_1 &lt;dbl&gt; 4, 4, 5, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 3, 3, 4, 3~ ## $ mvs_2 &lt;dbl&gt; 3, 3, 4, 3, 2, 4, 3, 3, 4, 3, 2, 4, 1, 3, 2, 3, 2, 4, 3~ ## $ mvs_3 &lt;dbl&gt; 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 2, 2, 3, 4, 4, 5, 3~ ## $ mvs_4 &lt;dbl&gt; 3, 3, 3, 2, 2, 5, 4, 4, 3, 4, 4, 4, 2, 2, 4, 3, 3, 4, 4~ ## $ mvs_5 &lt;dbl&gt; 3, 3, 4, 3, 3, 4, 3, 3, 4, 2, 2, 3, 3, 3, 4, 4, 4, 5, 3~ ## $ mvs_6 &lt;dbl&gt; 4, 4, 5, 2, 2, 3, 4, 4, 5, 2, 2, 3, 3, 3, 4, 2, 2, 3, 4~ ## $ mvs_7 &lt;dbl&gt; 3, 2, 4, 2, 3, 3, 3, 3, 4, 3, 1, 4, 4, 1, 5, 1, 3, 2, 3~ ## $ mvs_8 &lt;dbl&gt; 4, 4, 5, 4, 4, 5, 3, 3, 4, 3, 3, 4, 2, 2, 3, 3, 3, 4, 4~ ## $ mvs_9 &lt;dbl&gt; 2, 2, 1, 3, 3, 2, 3, 3, 2, 4, 4, 3, 4, 4, 3, 3, 3, 2, 3~ ## $ swb2019_1 &lt;dbl&gt; 3, 4, 3, 5, 4, 4, 2, 3, 4, 4, 4, 2, 3, 4, 3, 4, 4, 5, 3~ ## $ swb2019_2 &lt;dbl&gt; 3, 5, 3, 4, 3, 3, 2, 2, 4, 4, 4, 3, 2, 4, 3, 3, 3, 5, 4~ ## $ swb2019_3 &lt;dbl&gt; 4, 4, 3, 5, 3, 3, 3, 2, 4, 4, 3, 3, 2, 3, 2, 3, 3, 4, 3~ ## $ swb2019_4 &lt;dbl&gt; 4, 5, 4, 5, 3, 4, 2, 2, 3, 5, 3, 3, 3, 4, 3, 3, 4, 5, 3~ ## $ swb2019_5 &lt;dbl&gt; 3, 5, 4, 4, 4, 3, 2, 2, 4, 5, 4, 3, 2, 3, 2, 4, 4, 5, 3~ ## $ swb2021_1 &lt;dbl&gt; 3, 3, 2, 4, 3, 4, 1, 3, 3, 4, 4, 1, 2, 4, 3, 3, 4, 5, 3~ ## $ swb2021_2 &lt;dbl&gt; 3, 5, 2, 4, 2, 3, 1, 2, 3, 4, 3, 2, 1, 3, 2, 3, 3, 5, 3~ ## $ swb2021_3 &lt;dbl&gt; 4, 3, 3, 5, 3, 2, 3, 2, 4, 3, 3, 3, 2, 3, 1, 2, 2, 3, 3~ ## $ swb2021_4 &lt;dbl&gt; 4, 4, 4, 5, 3, 3, 2, 2, 3, 4, 3, 3, 3, 4, 2, 2, 3, 4, 3~ ## $ swb2021_5 &lt;dbl&gt; 3, 4, 4, 4, 4, 3, 2, 2, 4, 5, 4, 3, 2, 3, 2, 3, 4, 5, 3~ 3.4 Data wrangling with dplyr package Sometimes, a dataset can be overwhelming. We might want to, say, select specific columns to analyse. Or, we might only want to look at specific participants. Or we might want to create new variables from existing ones. All of these is made possible with functions in the dplyr package in tidyverse. The functions we will use in this class from the dplyr package are as follows: dplyr verbs Description select() select specific columns filter() filter (keep, select) specific rows mutate() create new columns summarise() summarise values group_by() apply operations to different groups There are more functions in the dplyr package. You can check out the dplyr cheat sheet HERE. 3.4.1 Select() This function allows us to select specific columns. This is especially useful if we have many columns to work with and we only want to focus on a few. Lets say we only want to select pin, and the swb2019_1 to swb2019_5 columns, we can: swb2019_only &lt;- data %&gt;% # create the subset called &quot;swb2019_only&quot; from &quot;data&quot; select(gender, swb2019_1:swb2019_5) # and select only pin and the columns swb2019_1 to swb2019_5 This is what the first six rows of swb2019_only should look like: ## # A tibble: 6 x 6 ## gender swb2019_1 swb2019_2 swb2019_3 swb2019_4 swb2019_5 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 3 3 4 4 3 ## 2 1 4 5 4 5 5 ## 3 1 3 3 3 4 4 ## 4 1 5 4 5 5 4 ## 5 1 4 3 3 3 4 ## 6 0 4 3 3 4 3 Although select() is used to select specific columns, I sometimes also use it to re-arrange the order of the columns. (In dplyr, the function to re-arrange the order of the columns is arrange(), which helps you re-arrange rows in addition to columns) Lets say we want the swb2019_1 to swb2019_5 columns to come before PIN. We can: swb2019_pinlast &lt;- data %&gt;% select(swb2019_1:swb2019_5, gender) This is what the first six rows of swb2019_pinlast should look like: ## # A tibble: 6 x 6 ## swb2019_1 swb2019_2 swb2019_3 swb2019_4 swb2019_5 gender ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 3 4 4 3 0 ## 2 4 5 4 5 5 1 ## 3 3 3 3 4 4 1 ## 4 5 4 5 5 4 1 ## 5 4 3 3 3 4 1 ## 6 4 3 3 4 3 0 3.4.2 Filter() Sometimes, we want to select specific kinds of participants to do our analyses on (e.g., say from specific conditions, or maybe only male or female participants). We use filter() to select those. New R users sometimes confuse select() with filter(). I like to differentiate them this way: filter() is used to select rows whereas select() is used to select columns. So, lets say we want to select only male participants. male_only &lt;- data %&gt;% # create &quot;male_only&quot; from &quot;data&quot;, filter(gender == &quot;male&quot;) # then filter (keep) only male participants Notice that the double equal sign == is used here. In programming languages, the == sign is used when we are comparing the left and the right hand side. Here, were comparing each row under the column gender to the word male. If that row matches the word male, we will filter (keep) that row. Otherwise, we will toss it out. This is what the first six rows of male_only should look like: ## # A tibble: 0 x 23 ## # ... with 23 variables: pin &lt;dbl&gt;, gender &lt;dbl&gt;, marital_status &lt;dbl&gt;, ## # have_children &lt;dbl&gt;, mvs_1 &lt;dbl&gt;, mvs_2 &lt;dbl&gt;, mvs_3 &lt;dbl&gt;, mvs_4 &lt;dbl&gt;, ## # mvs_5 &lt;dbl&gt;, mvs_6 &lt;dbl&gt;, mvs_7 &lt;dbl&gt;, mvs_8 &lt;dbl&gt;, mvs_9 &lt;dbl&gt;, ## # swb2019_1 &lt;dbl&gt;, swb2019_2 &lt;dbl&gt;, swb2019_3 &lt;dbl&gt;, swb2019_4 &lt;dbl&gt;, ## # swb2019_5 &lt;dbl&gt;, swb2021_1 &lt;dbl&gt;, swb2021_2 &lt;dbl&gt;, swb2021_3 &lt;dbl&gt;, ## # swb2021_4 &lt;dbl&gt;, swb2021_5 &lt;dbl&gt; 3.4.3 Mutate() Sometimes, we might want to create new variables, say averages or totals. Lets say we want to find the average of swb2019_1 to swb2019_5 for each participant. We use the subset we created just now, swb2019_only. swb2019_only &lt;- swb2019_only %&gt;% mutate(swb2019_avg = (swb2019_1 + swb2019_2 + swb2019_3 + swb2019_4 + swb2019_5) / 5) The first 6 rows of swb2019_only now looks like this: head(swb2019_only) ## # A tibble: 6 x 7 ## gender swb2019_1 swb2019_2 swb2019_3 swb2019_4 swb2019_5 swb2019_avg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 3 3 4 4 3 3.4 ## 2 1 4 5 4 5 5 4.6 ## 3 1 3 3 3 4 4 3.4 ## 4 1 5 4 5 5 4 4.6 ## 5 1 4 3 3 3 4 3.4 ## 6 0 4 3 3 4 3 3.4 At this point, youll notice that its kind of tedious to type (swb2019_1 + swb2019_2 + swb2019_3 + swb2019_4 + swb2019_5) / 5. Is there a shorter way to do this? Why, thank you for asking! The answer is yes, of course! This is where rowMeans comes in. swb2019_only &lt;- swb2019_only %&gt;% mutate(swb2019_avg_rowmeans = rowMeans(across(c(swb2019_1:swb2019_5)))) The first 6 rows of swb2019_only now looks like this: swb2019_only %&gt;% head(6) %&gt;% print(width = Inf) ## # A tibble: 6 x 8 ## gender swb2019_1 swb2019_2 swb2019_3 swb2019_4 swb2019_5 swb2019_avg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 3 3 4 4 3 3.4 ## 2 1 4 5 4 5 5 4.6 ## 3 1 3 3 3 4 4 3.4 ## 4 1 5 4 5 5 4 4.6 ## 5 1 4 3 3 3 4 3.4 ## 6 0 4 3 3 4 3 3.4 ## swb2019_avg_rowmeans ## &lt;dbl&gt; ## 1 3.4 ## 2 4.6 ## 3 3.4 ## 4 4.6 ## 5 3.4 ## 6 3.4 3.4.4 Summarise() The summarise() function creates summary statistics for a given column in the data frame such as the mean, median, maximum, minimum, etc. Lets say were interested to know the mean, minimum, maximum, variance, standard deviation, total number of participants for the variable. swb2019_only %&gt;% summarise(avg_YT2017 = mean(swb2019_avg), min_YT2017 = min(swb2019_avg), max_YT2017 = max(swb2019_avg), var_YT2017 = var(swb2019_avg), sd_YT2017 = sd(swb2019_avg), total = n()) ## # A tibble: 1 x 6 ## avg_YT2017 min_YT2017 max_YT2017 var_YT2017 sd_YT2017 total ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 3.35 1.6 5 0.543 0.737 343 3.4.5 Group_by() The group_by() verb allows us to split the data frame by some variable, apply a function to each data frame and then combine the output. For example, we can split the data frame by gender and then find the summary statistics for swb2019_avg for male and female separately. Lets say were interested to know the mean, minimum, maximum, variance, standard deviation, total number of participants for the variable swb2019_avg. swb2019_only %&gt;% group_by(gender) %&gt;% summarise(avg_YT2017 = mean(swb2019_avg), min_YT2017 = min(swb2019_avg), max_YT2017 = max(swb2019_avg), var_YT2017 = var(swb2019_avg), sd_YT2017 = sd(swb2019_avg), total = n()) ## # A tibble: 2 x 7 ## gender avg_YT2017 min_YT2017 max_YT2017 var_YT2017 sd_YT2017 total ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 0 3.08 2 4.8 0.373 0.611 168 ## 2 1 3.6 1.6 5 0.575 0.758 175 3.5 forcats "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
