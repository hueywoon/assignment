[["index.html", "PSYC208 R Companion Website About This Website", " PSYC208 R Companion Website Huey Woon LEE 2023-01-04 About This Website This is the companion website for my PSYC208 class. It was written as a gentle introduction to R. So, it is most certainly not exhaustive or comprehensive. If you’re interested in furthering your skills in R, there are plenty of resources available online which you can check out here, here or here. :) "],["getting-started.html", "1 Getting Started 1.1 Install R and RStudio 1.2 The RStudio Interface 1.3 R Script 1.4 Some Tips and Tricks", " 1 Getting Started To analyse data in R, you need both R and RStudio. These are different programmes. Think of R as the software that executes our commands and RStudio as the interface between us and R that makes interacting with R a much more pleasant experience. RStudio has many nifty features, like providing code suggestions and keyboard shortcuts that make writing code much faster and easier. For the sake of your sanity, I strongly recommend you download both programmes! 1.1 Install R and RStudio Install R For Windows Open an internet browser and go to https://cloud.r-project.org/. Under Download and Install R, Click on Download R for Windows. Click on base. Download the latest release by saving the .exe file on your computer. Double-click the file and follow the installation instructions. For macOS Open an internet browser and go to https://cloud.r-project.org/. Under Download and Install R, click on Download R for macOS. Download the latest release by saving the .pkg file to your computer. Double-click the file and follow the installation instructions. Install RStudio Now that R is installed, download and install RStudio. Go to https://www.rstudio.com/products/rstudio/download/. Click Download under RStudio Desktop. Click on the version recommended for your system, or the latest Windows / macOS version, and save the file. Double-click the file and follow the installation instructions. 1.2 The RStudio Interface Now, start up RStudio. You should see something like this: Figure 1.1: R Studio Interface With Three Panes When you first start up RStudio, you will see three panes: the R console, the workspace, and the files, plots, packages, help, and viewer pane. Each pane serves different purposes. R console: The R console is where commands are submitted to R for R to execute. It is also where we find some of the output from R (e.g., analysis results). Workspace: I think of this as R’s short-term memory. There are two tabs that are particularly useful. Environment tab: We can find the list of objects (e.g., variables, data frames, functions) that we created in the session here. History tab: Here is where we can find all the previous commands we submitted to R in the session. Files, plots, packages, help, and viewer: Files: We can create new folders on our computer, move, delete, and rename files here. Plots: We can find all the plots we instructed R to produce during the session here. Packages: We can find, install, and update packages here. Packages contain data, functions, help menus, etc. that other people have created to supplement those in R. We will talk more about specific packages later. Help: We can find information about a given command or package. We can also find more information about various commands and the packages on this website: https://www.rdocumentation.org/ Note. Because the Terminal tab, the Connections tab, and the Viewer tab will not be used in this course, I will not talk about them. 1.3 R Script To get R to do stuff (e.g., conduct analyses), we submit commands to R through RStudio. Although we can type the commands directly into the console, R users prefer to type the commands into what is called the script editor because we can save the commands in the script editor into script files (with the extension .R). The script files allow us to keep long-term records of the analyses that we have conducted. We can also share the script files with other R users so that they can reproduce our analyses. (In this class, I will use command and code interchangeably.) To open a blank R script, go to File &gt; New File &gt; R Script. Or, you can use the shortcut Ctrl + Shift + N (Windows) or Cmd + Shift + N (macOS). Notice that now, your RStudio has four panes. The script editor should now take up the top half of the left hand side of the screen as shown below. Figure 1.2: R Studio With Four Panes 1.4 Some Tips and Tricks Before we start coding proper, here are some tips to help you along your R journey. (These are things I wish I knew when I first started out!) 1.4.1 Softwrap Long Lines Sometimes, we might write commands in the Script editor section that are too long (horizontally) to fit the window. To see the entire command, we might need to scroll left and right. This can be frustrating. (It’s like notepad, without word wrap.) Fortunately, we can wrap the text such that the code fits into the size of the window. Go to Code &gt; Soft Wrap Long Lines. I highly recommend you do this, especially if you tend to write a lot of comments in the script file like I do. 1.4.2 Make Notes or Comments In R (and most programming languages), you can write notes or comments in the script to yourself and your readers. This is done by starting the line with a # sign. Please make liberal use of comments. I cannot tell you how many times comments have helped me understand what I’m doing and why. Your future self will thank you. Trust me. 1.4.3 Style Guide I strongly believe that people should be able to reproduce each others’ analyses. This provides the checks and balances that is important for science to advance. Therefore, you should be willing and able to share your code. But even if you do share your code, if it is unintelligible, it will not be of much help. Therefore, to make your code understandable, in addition to writing comments in the script, you should also follow certain conventions when writing code. These conventions are laid out in the tidyverse Style Guide. You can read the Style Guide here: https://style.tidyverse.org/syntax.html. 1.4.4 Setting working directory Typically when we analyse data, we need to reference external files (e.g., our data files). To tell R where to look for those data files, we need to specify the full file path (i.e., the file location). While this is fine if you only have one or two things to reference, it can be kind of tedious to keep typing the file path if you have many things to reference. Furthermore, if you choose to change your file location, it would be quite a hassle (and also error-prone) to have to update all those file paths in the script. What we can do instead is to set a working directory in R using the function setwd(). This tells R where your data files are stored for the session, so it will know to look there. It will also be the place that R saves any output (e.g., plots). To get the file location in Windows, we first go to the folder where the file is located, right-click on the address bar, and click Copy address as text. We then need to convert the backslashes in the file path to forward slashes before we can use it. Let’s say the file path is C:\\Users\\Win10\\Desktop\\R. After converting all the backslashes to forward slashes, the file path to use is C:/Users/Win10/Desktop/R. In macOS, there are several ways to get the file path. For instructions, please visit this website: https://www.dev2qa.com/how-to-get-file-path-in-mac/. Note that the file paths in macOS already use forward slashes, so changing backslashes to forward slashes is not an issue for macOS users. After getting the file path, you can then set the working directory as follows, with the file path encased in open/close inverted commas, within the parentheses. # Set working directory setwd(&quot;C:/Users/Win10/Desktop/R&quot;) 1.4.5 Using R Projects While setting the working directory manually is sufficient when we have one or two projects, many of us have multiple projects on-going at the same time. If we have a bunch of different files from different projects all strewn in a single directory (folder), it can get quite messy. To stay organised, it is best that we create an R project for each project we are working on. To do this, go to File &gt; New Project. A dialogue window with three options, “New Directory”, “Existing Directory” and “Version Control”, will appear. Select “New Directory”, followed by “New Project”. After RStudio has created the project, it will change the working directory to the project directory so that you can access all the files (e.g., data, script) related to this project in this directory. RStudio will also create a file with the extension .Rproj in the project directory. When you open this file, RStudio will automatically start a new session with the project directory as your working directory. While it is not absolutely necessary to use RStudio projects in this course, I recommend it because it will help keep you organized. 1.4.6 Debugging When you are programming, you will make errors (“bugs”) in your code. Trying to figure out where you made the error (“debugging”) can be extremely time-consuming and frustrating. To help you along, here are some of the most common bugs that you’ll run into. Misspelled object or function Misspelled object will throw this error message: Error: object not found Misspelled function will throw this error message: Error: could not find function R is case-sensitive. So if your object is called Data, you need to type Data and not data, else it will throw an error message. Punctuation mistake Remember to close the parenthesis () Don’t add a space where there shouldn’t be. For example, if your object is called datafile, don’t type data file. Use the correct punctuation for the function. For example, if the function requires a comma, don’t put in full stops. If it requires a double equal sign, don’t put in a single equal sign. If you’ve tried all the above and still can’t figure out what’s going on, just copy and paste the warning into the search engine. 99% of the time, you’ll be able to figure out what happened by reading forum posts. (Programmers are super helpful!) 1.4.7 Last Words In general, students new to programming tend to be hesitant to experiment, worried that they’d break the software or something. I promise you that this rarely happens (except maybe when you write a loop function that doesn’t stop looping!). So just have fun and experiment. If RStudio freezes, just close it and re-start! Congrats! You’ve now installed R and RStudio! You’re now ready to move on to some basics! =D "],["basics.html", "2 Basics 2.1 Some Basic Commands 2.2 Typing and Executing Commands 2.3 Entering Data Directly Into R", " 2 Basics 2.1 Some Basic Commands Before typing commands into the script editor, it might be useful for you to know some of the following basic commands. To place a comment in the script file, begin the line with #. To run (execute) a line in the script file, place the cursor on the line, hit Ctrl + Enter (Windows) or Cmd + Enter (macOS). If we typed the command directly into the console, we only need to hit Enter To run multiple lines in the script file, select the lines, hit Ctrl + Enter (Windows) or Cmd + Enter (macOS). To clear the console when it becomes too messy, hit Ctrl + L (Windows) or Cmd + L (macOS). To request help, type a question mark in front of the command or the package name (e.g., ?cor). Information about the command will appear in the Help tab (lower right pane). 2.2 Typing and Executing Commands Now, let’s actually get R to do stuff for us! Open a script file (Ctrl/CMD + Shift + N). Then copy and paste the following R codes into the script file. Run each line (Ctrl/Cmd + Enter) to see what they do. Note that # denotes a comment, and therefore it will run as a line of text. Experiment and have fun! # Assign a single value (e.g., 9) to an object, say x. x &lt;- 9 # this means &quot;x gets the value of 9&quot;. # Get the value for x. x # remember that R is case-sensitive. If you typed X, you&#39;ll get an error message. X # see how R complains here that it can&#39;t find the object? # If you want to know what objects are in the workspace (i.e., R&#39;s memory), look at the Environment tab or type ls(). ls() # You may remove an object (e.g., x) from the workspace using rm(), where rm stands for remove. rm(x) # If there are too many objects in the workspace, you may remove all objects from the workspace using rm(list=ls()). rm(list = ls()) # Assign a non-numerical value by putting the value in quotation marks. y &lt;- &quot;hello!&quot; # Get the value of y. Notice the value of y is in quotation marks, indicating it is a non-numerical value. y # Perform the following mathematical operations in R. 11 + 10 11 - 10 11 * 10 11 / 10 11 ^ 10 11 ^ (1/2) sqrt(11) # this number should be the same as above line log(11) # taking natural log (log base e) log10(11) # taking log base 10 exp(11) # taking the exponential # Perform mathematical operations in R with an object (e.g., a). a &lt;- 11 # a gets the value of 11 a + 10 a - 10 a * 10 a / 10 a ^ (1/2) sqrt(a) log(a) log10(a) exp(a) # Perform mathematical operations with more than one object. y &lt;- 2 # notice that 2 now replaces the value “hello”. a + y a - y a * y a / y a ^ (1/y) # You cannot perform mathematical operations with non-numerical objects. b &lt;- &quot;1&quot; # recall, putting things in between quotation marks makes it non-numerical, even if 1 is a number. a + b # you get an error here because you cannot perform mathematical operations with non-numerical objects. # An object can store more than one value, such as a set of numbers or a set of characters. This is known as a vector and can be created using c(). num_vector &lt;- c(1, 2, 3, 4, 5) # numeric vector fruits &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;) # non-numeric vector # Get the values stored in the vectors num_vector fruits # You can do mathematical operations with numerical vectors but not with non-numerical vectors. num_vector * 5 # each value in num_vector is multiplied by 5 fruits * 5 # this throws an error that tells you that you cannot use non-numeric values for this operation 2.3 Entering Data Directly Into R In reality, we rarely use R to do such simple mathematical calculations; we use R for data analyses. But before we can conduct any analysis, we need to give R some data. One way is to key the data directly into R. Let’s say we have three people, Bob, Andrea, and Calvin. We have their ages, the number of children each of them has, and their gender. Name Age No. of Children Gender Bob 48 1 Male Andrea 47 3 Female Calvin 49 2 Male Let’s figure out how to give R this set of data. First, we create an object name, and assign the three people’s names to it. name &lt;- c(&quot;Bob&quot;, &quot;Andrea&quot;, &quot;Calvin&quot;) # notice the names are between quotation marks # this tells R that name is a string (non-numerical) variable If we type name into the console, we should get: ## [1] &quot;Bob&quot; &quot;Andrea&quot; &quot;Calvin&quot; Next, we create the object age, with the three people’s ages. age &lt;- c(48, 47, 49) # notice the order of age should match the order of the names If we type age into the console, we should get: ## [1] 48 47 49 Now, let’s combine the two variables into a data frame, which we will call data, such that each row in data represents the information for one person, and name and age are in side-by-side columns by using the data.frame() function. data &lt;- data.frame(Name = name, Age = age) # Name = name tells R that the variable name should have the header Name. # Age = age tells R that the variable age should have the header Age. Type data into the console. You should see: ## Name Age ## 1 Bob 48 ## 2 Andrea 47 ## 3 Calvin 49 Notice that the output has the Name and the Age columns. Name lists the names of the three individuals. Age lists the ages of the three individuals. The values of Name and Age in the data frame were copied from the original objects. This means that the original objects, name and age, are still in R’s memory. You can see that this is the case from the Environment tab or when you use the ls() function. ## [1] &quot;age&quot; &quot;data&quot; &quot;name&quot; Let’s remove the original variables name and age. rm(name) rm(age) Now, when you type ls() into the console, you’ll see that all is left is the data frame, data. ## [1] &quot;data&quot; If we want to use the variables in the data frame data, we need to attach data$ (a dollar sign after the name of the data frame) before the variable name. For example, if we want to know the ages of the three participants: data$Age ## [1] 48 47 49 # remember that R is case-sensitive. So if you&#39;d typed data$age, you&#39;ll get an error. Let’s say we have more variables to add to the data frame data: the number of children the person has and the person’s gender. Let’s label the number of children each person has as Children and the gender of each person as Gender. data$Children &lt;- c(1, 3, 2) data$Gender &lt;- c(&quot;male&quot;, &quot;female&quot;, &quot;male&quot;) # again, notice the order of Children and Gender should match the order of the names Now, when you type data into the console, you’ll get: ## Name Age Children Gender ## 1 Bob 48 1 male ## 2 Andrea 47 3 female ## 3 Calvin 49 2 male Note that we created Children and Gender within the data frame. So if you type Children and Gender without data$, you will get an error message in the console telling you that the object cannot be found. Now, let’s say we made a mistake and need to remove Children from the data frame, data. We can type: data$Children &lt;- NULL # assign the value of NULL to data$Children data ## Name Age Gender ## 1 Bob 48 male ## 2 Andrea 47 female ## 3 Calvin 49 male # notice that the Children column is now gone Finally, if we want to save the data frame into a .csv file, we use write.csv(). write.csv(data, &quot;bobandreacalvin.csv&quot;) # specify the name and extension of the file (bobandreacalvin.csv). The .csv file will now be saved as bobandreacalvin.csv within your current directory. If you use an R project, it will be saved in your project directory. Otherwise, it will be in your default directory. If you don’t know what the directory is, type getwd() into the console. Now that you’ve gotten to this point, I think you’re ready to do your first assignment! Proceed to the next section! "],["tha1.html", "3 Assignment 1 3.1 Due Date: 19-01-2023 3.2 Instructions 3.3 Data", " 3 Assignment 1 3.1 Due Date: 19-01-2023 3.2 Instructions Please read through the Getting Started and the Basics pages before working on this assignment, especially if you have no background in R. Download R. Download RStudio. Set working directory. Suppose we have the starting monthly salary of 10 men and 10 women (see Data section below). Enter the data provided into a data frame where one column represents the biological sex of the individual (call this column BioSex) and the other column represents the starting monthly salary (call this column Salary) of the individual. Check that you have 20 rows (one for each individual) and 2 columns (one for each variable). Save the data frame into a .csv file. Name this file data.csv. For each step above, put in comments using the # sign so that you know what was done. (e.g., # set working directory) When you’re done with the above, copy and paste your R script into a word document. Submit the word document in the eLearn Assignment for 1 point. Note. Answers will be released on eLearn the day after this assignment is due. 3.3 Data Man Woman 3530 3790 4730 2720 4330 3170 3560 3320 4050 3190 4880 2890 4190 2920 3620 3390 3530 3790 5070 3680 "],["tidyverse.html", "4 Using tidyverse 4.1 Installing and Loading tidyverse 4.2 Import Data 4.3 Factors 4.4 Data Wrangling With dplyr 4.5 Tables and Plots with ggplot2", " 4 Using tidyverse Now that you have some basics under your belt, let’s move on to installing and using packages from tidyverse! The tidyverse is a collection of R packages that many data analysts use. You can think of packages as collections of R codes (and more!) that other people have created to make R more powerful or easier to use. In this course, we will be heavily relying on a few of the packages such as readr, dplyr and ggplot2 that are in the tidyverse collection. Instead of installing each package separately as we normally would, we can simply install tidyverse and that would install all the other packages that we want. 4.1 Installing and Loading tidyverse To install tidyverse, use the function install.packages(). install.packages(&quot;tidyverse&quot;) Even after we have installed tidyverse, we cannot use it unless we load it. To load it, we need the library() function. library(tidyverse) Note. You can temporarily load a package without using the library() function using the notation package::function. This tells R to load the package for a specific chunk of code and not for the entire session. This allows anyone who reads the code to know which package the function comes from. I typically don’t do this because it can be quite tiresome to keep typing the name of the package over and over. However, package::function comes in especially handy when we want to help R distinguish between two packages with the same function names. For example, the packages ggplot2 and psych both have a function alpha(). R doesn’t know which package to choose if you have both packages loaded. So, to specify that you want to use the function from the psych package, you should type psych::alpha(). Now that we have tidyverse loaded, let’s do stuff with it. Let’s start with importing data. 4.2 Import Data Usually, R users do not have to enter their data into R directly. Instead, they already have their dataset in various formats, such as .csv, .txt, .sav, .xlsx, etc. So what they need to do is to import the dataset into R. In this class, I will use .csv files. To import .csv files, we can use the read_csv() function from the readr package in tidyverse. I have created a hypothetical dataset for my examples here. To follow along, please download the dataset here: SWB.csv. In this hypothetical dataset, 343 participants provided demographic information and responded to the Materialism Values Survey (MVS) and the Satisfaction with Life Scale in 2019 (SWLS2019). The same participants were asked to respond to the Satisfaction with Life Scale in 2021 (SWLS2021). The legend for this dataset is as follows: Variable Name Variable Label Value Label pin participant identification number gender gender 0 = male, 1 = female marital_status marital status 1 = married, 2 = divorced, 3 = widowed have_children parental status 0 = no children, 1 = have children mvs_1 My life would be better if I own certain things I don’t have. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_2 The things I own say a lot about how well I’m doing. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_3 I’d be happier if I could afford to buy more things. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_4 It bothers me that I can’t afford to buy things I’d like. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_5 Buying things gives me a lot of pleasure. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_6 I admire people who own expensive homes, cars, clothes. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_7 I like to own things that impress people. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_8 I like a lot of luxury in my life. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_9 I try to keep my life simple, as far as possessions are concerned. (R) 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree swls2019_1 In most ways my life is close to my ideal. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2019_2 The conditions of my life are excellent. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2019_3 I am satisfied with my life. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2019_4 So far I have gotten the important things I want in life. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2019_5 In most ways my life is close to my ideal. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_1 In most ways my life is close to my ideal. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_2 The conditions of my life are excellent. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_3 I am satisfied with my life. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_4 So far I have gotten the important things I want in life. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_5 In most ways my life is close to my ideal. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree Let’s read in the .csv file. data &lt;- read_csv(&quot;SWB.csv&quot;) # this code is saying... # read in the .csv file, &quot;SWB.csv&quot; and assign it to the object &quot;data&quot; # from now on, &quot;data&quot; will refer to the data in this csv file You may also use the built-in R function read.csv(). If you do so, you don’t have to load the tidyverse package. data &lt;- read.csv(&quot;SWB.csv&quot;) read.csv() is supposedly slower than read_csv(), which in turn is slower than data.table’s fread(). For our purposes, though, it really doesn’t matter which you use, so long as you can successfully import the data file. If you have other file types, such as .txt, .sav, .xlsx, you might need different packages. For example, for excel files (.xlsx), you will need the readxl package. For SPSS (.sav), you will need the haven package or the foreign package. For this class, I won’t use file types aside from .csv, but it is good to be aware of the packages to use if you want to import other file types. 4.2.1 Check Imported Dataset Before conducting any analyses, check that the dataset has been imported correctly. Go to the Environment pane (top right pane). Click data. The top left pane should show the imported data. Alternatively, you may type View(data) into the console. Rows: The data for each participant is recorded in a single row (e.g., data for Participant 1 is in Row 1) Columns: The data for each variable is recorded in a single column. Names of the variables are in the headers for each column Scroll down to ensure all rows have been imported correctly. There should be 343 rows. Scroll right to ensure all columns have been imported correctly. There should be 23 columns. Another way to check the imported dataset is using the str() or the glimpse() functions. Both give you roughly similar information (e.g., that there are 343 rows and 23 columns, the names of the variables, the values for the first 10 or so participants) str(data) ## spc_tbl_ [343 × 23] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ pin : num [1:343] 1 2 3 4 5 6 7 8 9 10 ... ## $ gender : num [1:343] 0 1 1 1 1 0 1 0 1 0 ... ## $ marital_status: num [1:343] 1 1 3 1 2 1 2 1 2 1 ... ## $ have_children : num [1:343] 0 1 0 0 0 1 0 0 0 1 ... ## $ mvs_1 : num [1:343] 4 4 5 2 2 3 2 2 3 2 ... ## $ mvs_2 : num [1:343] 3 3 4 3 2 4 3 3 4 3 ... ## $ mvs_3 : num [1:343] 3 3 4 3 3 4 3 3 4 3 ... ## $ mvs_4 : num [1:343] 3 3 3 2 2 5 4 4 3 4 ... ## $ mvs_5 : num [1:343] 3 3 4 3 3 4 3 3 4 2 ... ## $ mvs_6 : num [1:343] 4 4 5 2 2 3 4 4 5 2 ... ## $ mvs_7 : num [1:343] 3 2 4 2 3 3 3 3 4 3 ... ## $ mvs_8 : num [1:343] 4 4 5 4 4 5 3 3 4 3 ... ## $ mvs_9 : num [1:343] 2 2 1 3 3 2 3 3 2 4 ... ## $ swls2019_1 : num [1:343] 4 5 4 6 5 5 2 4 5 5 ... ## $ swls2019_2 : num [1:343] 4 6 4 5 4 4 3 3 5 5 ... ## $ swls2019_3 : num [1:343] 5 5 4 7 4 4 3 3 5 5 ... ## $ swls2019_4 : num [1:343] 5 6 5 6 4 5 3 3 4 6 ... ## $ swls2019_5 : num [1:343] 4 6 5 5 5 4 3 3 5 6 ... ## $ swls2021_1 : num [1:343] 4 4 3 5 4 5 2 4 4 5 ... ## $ swls2021_2 : num [1:343] 4 6 3 5 3 4 2 3 4 5 ... ## $ swls2021_3 : num [1:343] 5 4 4 6 4 3 4 3 5 4 ... ## $ swls2021_4 : num [1:343] 5 5 5 6 4 4 3 3 4 5 ... ## $ swls2021_5 : num [1:343] 4 5 5 5 5 4 3 3 5 6 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. pin = col_double(), ## .. gender = col_double(), ## .. marital_status = col_double(), ## .. have_children = col_double(), ## .. mvs_1 = col_double(), ## .. mvs_2 = col_double(), ## .. mvs_3 = col_double(), ## .. mvs_4 = col_double(), ## .. mvs_5 = col_double(), ## .. mvs_6 = col_double(), ## .. mvs_7 = col_double(), ## .. mvs_8 = col_double(), ## .. mvs_9 = col_double(), ## .. swls2019_1 = col_double(), ## .. swls2019_2 = col_double(), ## .. swls2019_3 = col_double(), ## .. swls2019_4 = col_double(), ## .. swls2019_5 = col_double(), ## .. swls2021_1 = col_double(), ## .. swls2021_2 = col_double(), ## .. swls2021_3 = col_double(), ## .. swls2021_4 = col_double(), ## .. swls2021_5 = col_double() ## .. ) ## - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; glimpse(data) ## Rows: 343 ## Columns: 23 ## $ pin &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, … ## $ gender &lt;dbl&gt; 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0… ## $ marital_status &lt;dbl&gt; 1, 1, 3, 1, 2, 1, 2, 1, 2, 1, 3, 2, 3, 3, 3, 1, 1, 1, 3… ## $ have_children &lt;dbl&gt; 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0… ## $ mvs_1 &lt;dbl&gt; 4, 4, 5, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 3, 3, 4, 3… ## $ mvs_2 &lt;dbl&gt; 3, 3, 4, 3, 2, 4, 3, 3, 4, 3, 2, 4, 1, 3, 2, 3, 2, 4, 3… ## $ mvs_3 &lt;dbl&gt; 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 2, 2, 3, 4, 4, 5, 3… ## $ mvs_4 &lt;dbl&gt; 3, 3, 3, 2, 2, 5, 4, 4, 3, 4, 4, 4, 2, 2, 4, 3, 3, 4, 4… ## $ mvs_5 &lt;dbl&gt; 3, 3, 4, 3, 3, 4, 3, 3, 4, 2, 2, 3, 3, 3, 4, 4, 4, 5, 3… ## $ mvs_6 &lt;dbl&gt; 4, 4, 5, 2, 2, 3, 4, 4, 5, 2, 2, 3, 3, 3, 4, 2, 2, 3, 4… ## $ mvs_7 &lt;dbl&gt; 3, 2, 4, 2, 3, 3, 3, 3, 4, 3, 1, 4, 4, 1, 5, 1, 3, 2, 3… ## $ mvs_8 &lt;dbl&gt; 4, 4, 5, 4, 4, 5, 3, 3, 4, 3, 3, 4, 2, 2, 3, 3, 3, 4, 4… ## $ mvs_9 &lt;dbl&gt; 2, 2, 1, 3, 3, 2, 3, 3, 2, 4, 4, 3, 4, 4, 3, 3, 3, 2, 3… ## $ swls2019_1 &lt;dbl&gt; 4, 5, 4, 6, 5, 5, 2, 4, 5, 5, 5, 3, 4, 5, 4, 5, 5, 6, 4… ## $ swls2019_2 &lt;dbl&gt; 4, 6, 4, 5, 4, 4, 3, 3, 5, 5, 5, 4, 3, 5, 4, 4, 4, 6, 5… ## $ swls2019_3 &lt;dbl&gt; 5, 5, 4, 7, 4, 4, 3, 3, 5, 5, 4, 4, 3, 4, 3, 4, 4, 5, 4… ## $ swls2019_4 &lt;dbl&gt; 5, 6, 5, 6, 4, 5, 3, 3, 4, 6, 4, 4, 4, 5, 4, 4, 5, 6, 4… ## $ swls2019_5 &lt;dbl&gt; 4, 6, 5, 5, 5, 4, 3, 3, 5, 6, 5, 4, 3, 4, 3, 5, 5, 6, 4… ## $ swls2021_1 &lt;dbl&gt; 4, 4, 3, 5, 4, 5, 2, 4, 4, 5, 5, 2, 3, 5, 4, 4, 5, 6, 4… ## $ swls2021_2 &lt;dbl&gt; 4, 6, 3, 5, 3, 4, 2, 3, 4, 5, 4, 3, 2, 4, 3, 4, 4, 6, 4… ## $ swls2021_3 &lt;dbl&gt; 5, 4, 4, 6, 4, 3, 4, 3, 5, 4, 4, 4, 3, 4, 2, 3, 3, 4, 4… ## $ swls2021_4 &lt;dbl&gt; 5, 5, 5, 6, 4, 4, 3, 3, 4, 5, 4, 4, 4, 5, 3, 3, 4, 5, 4… ## $ swls2021_5 &lt;dbl&gt; 4, 5, 5, 5, 5, 4, 3, 3, 5, 6, 5, 4, 3, 4, 3, 4, 5, 6, 4… 4.3 Factors When you look at the output from str(data) or glimpse(data), you can see that some values don’t seem to make sense on their own. For example, what do 0 and 1 in gender mean? From the legend table produced earlier, we can see that 0 stands for male and 1 stands for female. But having to consult the table every time we do an analysis is tiresome and also error-prone. So, we use the factor() command to tell R what those values mean for categorical variables. data$gender &lt;- factor(data$gender, levels = c(0, 1), labels = c(&quot;male&quot;, &quot;female&quot;)) # Here, we are telling R that level 0 = label “male”, level 1 = label “female” # Also notice that male and female are enclosed in quotation marks (string variables). # Check that gender is now a factor glimpse(data$gender) ## Factor w/ 2 levels &quot;male&quot;,&quot;female&quot;: 1 2 2 2 2 1 2 1 2 1 ... 4.4 Data Wrangling With dplyr What should we do after importing a dataset? Well, there are many things we can do! We might want to, say, select specific columns to analyse. Or, we might want to select only participants who completed all the questions in the survey. Or we might want to create new variables from existing ones. Or we might want to get some descriptive statistics like mean and standard deviation. All of that is made possible with functions in the dplyr package in tidyverse. The functions we will use in this class from the dplyr package are as follows: dplyr functions Description select() select specific columns filter() filter (keep, select) specific rows mutate() create new columns summarise() summarise values group_by() apply operations to different groups There are more functions in the dplyr package! Check out the dplyr cheat sheet here: https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf. Now, let’s go through the five listed above. 4.4.1 Select() The select() function allows us to select specific columns. This is especially useful if we have many columns to work with and we only want to focus on a few. Let’s say we only want to select gender and the swls2019_1 to swls2019_5 columns in the SWB dataset. Here’s how we would do it: swls2019_only &lt;- data %&gt;% # create the subset called &quot;swls2019_only&quot; from &quot;data&quot; select(gender, swls2019_1:swls2019_5) # and select only gender and the columns swls2019_1 to swls2019_5 This is what the first six rows of swls2019_only should look like: ## # A tibble: 6 × 6 ## gender swls2019_1 swls2019_2 swls2019_3 swls2019_4 swls2019_5 ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 male 4 4 5 5 4 ## 2 female 5 6 5 6 6 ## 3 female 4 4 4 5 5 ## 4 female 6 5 7 6 5 ## 5 female 5 4 4 4 5 ## 6 male 5 4 4 5 4 I sometimes also use select() to re-arrange the order of the columns. (In dplyr, the specific function to re-arrange the order of the columns is arrange(). arrange() allows us to re-arrange rows in addition to columns.) So, let’s say we want the swls2019_1 to swls2019_5 columns to come before gender. We simply list the swls2019_1 to swls2019_5 columns before gender. swls2019_genderlast &lt;- data %&gt;% select(swls2019_1:swls2019_5, gender) This is what the first six rows of swls2019_genderlast should look like: ## # A tibble: 6 × 6 ## swls2019_1 swls2019_2 swls2019_3 swls2019_4 swls2019_5 gender ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 4 4 5 5 4 male ## 2 5 6 5 6 6 female ## 3 4 4 4 5 5 female ## 4 6 5 7 6 5 female ## 5 5 4 4 4 5 female ## 6 5 4 4 5 4 male 4.4.2 Filter() Maybe we don’t want to select specific columns. Instead, we want to select specific kinds of participants to conduct our analyses on (e.g., say from specific treatment groups, or maybe only male participants). We use filter() to do that. New R users sometimes confuse select() with filter(). Here’s how to differentiate the two: select() is used to select columns (i.e., variables) whereas filter() is used to select rows (i.e., participants). So, let’s say we want to select only male participants. male_only &lt;- data %&gt;% # create &quot;male_only&quot; subset from &quot;data&quot;, filter(gender == &quot;male&quot;) # then filter (keep) only male participants Notice that the double equal sign == is used here. In programming languages, the == sign is used when we are comparing the left and the right hand side. Here, we’re comparing each row of the column gender to the word “male”. If that row matches the word “male”, we will filter (keep) that row. Otherwise, we will toss it out. This is what the first six rows of male_only should look like: ## # A tibble: 6 × 23 ## pin gender marital…¹ have_…² mvs_1 mvs_2 mvs_3 mvs_4 mvs_5 mvs_6 mvs_7 mvs_8 ## &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 male 1 0 4 3 3 3 3 4 3 4 ## 2 6 male 1 1 3 4 4 5 4 3 3 5 ## 3 8 male 1 0 2 3 3 4 3 4 3 3 ## 4 10 male 1 1 2 3 3 4 2 2 3 3 ## 5 11 male 3 0 2 2 3 4 2 2 1 3 ## 6 14 male 3 0 2 3 2 2 3 3 1 2 ## # … with 11 more variables: mvs_9 &lt;dbl&gt;, swls2019_1 &lt;dbl&gt;, swls2019_2 &lt;dbl&gt;, ## # swls2019_3 &lt;dbl&gt;, swls2019_4 &lt;dbl&gt;, swls2019_5 &lt;dbl&gt;, swls2021_1 &lt;dbl&gt;, ## # swls2021_2 &lt;dbl&gt;, swls2021_3 &lt;dbl&gt;, swls2021_4 &lt;dbl&gt;, swls2021_5 &lt;dbl&gt;, and ## # abbreviated variable names ¹​marital_status, ²​have_children 4.4.3 Mutate() Sometimes, we might want to create new variables, say averages or totals. We can do this with mutate(). Let’s say we want to find the average of swls2019_1 to swls2019_5 for each participant. We use the subset we created just now, swls2019_only. swls2019_only &lt;- swls2019_only %&gt;% mutate(swls2019_avg = (swls2019_1 + swls2019_2 + swls2019_3 + swls2019_4 + swls2019_5) / 5) # create a variable called `swls2019_avg` by adding up swls2019_1 to swls2019_5 and then dividing the total by 5 The first 6 rows of swls2019_only now looks like this: ## # A tibble: 6 × 7 ## gender swls2019_1 swls2019_2 swls2019_3 swls2019_4 swls2019_5 swls2019_avg ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 male 4 4 5 5 4 4.4 ## 2 female 5 6 5 6 6 5.6 ## 3 female 4 4 4 5 5 4.4 ## 4 female 6 5 7 6 5 5.8 ## 5 female 5 4 4 4 5 4.4 ## 6 male 5 4 4 5 4 4.4 There is another way you can achieve the same results using rowMeans(). swls2019_only &lt;- swls2019_only %&gt;% mutate(swls2019_avg_rowmeans = rowMeans(across(c(swls2019_1:swls2019_5)))) # rowMeans(across(c(swls2019_1:swls2019_5))) tells R that we want to find the mean (average) for each row (hence rowMeans) across the five variables, swls2019_1 to swls2019_5. Let’s compare swls2019_avg and swls2019_avg_rowmeans. Notice that the two columns give you the exact same results: ## # A tibble: 6 × 2 ## swls2019_avg swls2019_avg_rowmeans ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4.4 4.4 ## 2 5.6 5.6 ## 3 4.4 4.4 ## 4 5.8 5.8 ## 5 4.4 4.4 ## 6 4.4 4.4 4.4.4 Summarise() The summarise() function is used when we want to get summary statistics such as the mean, median, maximum, minimum, etc for a given column in the data frame. Let’s say we’re interested to know the mean (avg_swls), minimum (min_swls), maximum (max_swls), variance (var_swls), standard deviation (sd_swls), total number of participants (total) for swls2019_avg. Again, we will use our swls2019_only subset. swls2019_only %&gt;% summarise(avg_swls = mean(swls2019_avg), min_swls = min(swls2019_avg), max_swls = max(swls2019_avg), var_swls = var(swls2019_avg), sd_swls = sd(swls2019_avg), total = n()) ## # A tibble: 1 × 6 ## avg_swls min_swls max_swls var_swls sd_swls total ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 4.35 2 6 0.588 0.767 343 4.4.5 Group_by() Sometimes, we might want to apply the same function to different groups of people. For example, we might want to know what the maximum swls score is for males and for females separately. We can use the group_by() function to do this. Let’s say we’re interested to know the mean (avg_swls), minimum (min_swls), maximum (max_swls), variance (var_swls), standard deviation (sd_swls), total number of participants (total) for swls2019_avg for males and females separately. swls2019_only %&gt;% group_by(gender) %&gt;% summarise(avg_swls = mean(swls2019_avg), min_swls = min(swls2019_avg), max_swls = max(swls2019_avg), var_swls = var(swls2019_avg), sd_swls = sd(swls2019_avg), total = n()) ## # A tibble: 2 × 7 ## gender avg_swls min_swls max_swls var_swls sd_swls total ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 male 4.08 3 5.8 0.373 0.611 168 ## 2 female 4.62 2 6 0.657 0.810 175 At this point, you should realise that it is possible to combine different dplyr functions to achieve specific results. I encourage you to play around! 4.5 Tables and Plots with ggplot2 Okay, so what else can we do with the data? Well, we can create tables and graphs! Why might we do this? Well… Tables and graphs provide us a way to visualize the data. They show us the distribution of the data and allow us to discover any errors or interesting patterns. Let’s start with the frequency tables. 4.5.1 Frequency Tables A frequency table tells us the number of times each data value occurs for a given variable. Let’s say we want to know how many males and how many females participated in the study using the swls2019_only subset. The variable is gender and the data values we are interested in are male and female. Before looking at my code below, try coming up with your own! (HINT: Use the summarise() function!) swls2019_only %&gt;% group_by(gender) %&gt;% # Group the result by gender summarise(freq = n()) # Count how many of each value in the data ## # A tibble: 2 × 2 ## gender freq ## &lt;fct&gt; &lt;int&gt; ## 1 male 168 ## 2 female 175 The output tells us 168 males and 175 females participated in the study. The number of times a data value occurs for a given variable is called the absolute frequency. If we want the relative frequency (i.e., the number of times a data value occurs relative to the total number of observations for a given variable), then we divide the absolute frequency by the total number of values. swls2019_only %&gt;% group_by(gender) %&gt;% # Group the result by gender summarise(freq = n()) %&gt;% # Count how many of each value in the data mutate (total = sum(freq), # Count the total number of observations rel_freq = freq / total) # Take the frequency of each value / total number of observations ## # A tibble: 2 × 4 ## gender freq total rel_freq ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 male 168 343 0.490 ## 2 female 175 343 0.510 The output (rel_freq) tells us that 49% of the sample are males and 51% of the sample are females. (Relative frequency is in proportion, and we can convert proportions into percentages by taking 100%.) 4.5.2 Bar Plots With ggplot2 Maybe you want a bar chart or bar plot to visually represent the frequency table instead. (Note that bar charts or bar plots are used for categorical variables only.) We will use ggplot2, a package developed for data visualization. Every plot in ggplot2 is plotted with three components: data, aesthetics, and geometry. Data: specifies the dataframe Aesthetics: specifies the variables that we want to plot as well as aesthetics, like colour Geometry: specifies the type of plot &amp; other modifications These three components apply when we make any plot in ggplot2. Let’s make a bar chart with ggplot2 with the code below. ggplot(data = swls2019_only, aes(x = gender)) + # dataset used is swls2019_only, x (horizontal axis) is gender geom_bar(stat=&quot;count&quot;) # we want a bar plot where the statistic is the count of the values in x Here’s an alternative that will give you the exact same output. # Alternative swls2019_only %&gt;% # dataset used is swls2019_only ggplot(.) + # R takes swls2019_only in the previous line and places it in the . on this line to tell ggplot that dataset used is swls2019_only geom_bar(aes(x = gender), stat=&quot;count&quot;) # we want a bar plot where x (horizontal axis) is gender and the statistic is the count of values in x Notice that the aes() command can be either in the ggplot line or the geom function line. Where you type it doesn’t affect the results at all. (Try this out yourself to confirm!) I personally prefer the alternative because it’s easier for me to read, but it doesn’t matter to me which you use! 4.5.3 Histograms with ggplot2 We create bar plots for categorical variables (such as gender). For continuous variables, we create histograms. A histogram is a visual representation of the frequency table for a given continuous variable (i.e., it shows us the frequency distribution, or the frequency of scores for a given continuous variable). Let’s use ggplot2 to make a histogram for swls2019_avg with a very simple code. ggplot(swls2019_only, aes(x = swls2019_avg)) + geom_histogram() # we want a histogram, so geom_histogram() is used ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. As with the bar chart, you could do this instead and the results would be the same: swls2019_only %&gt;% ggplot(.) + geom_histogram(aes(x = swls2019_avg)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Now, the histogram that you got is okay, but maybe you want to customise it even more. For example, you might want to add a specific label for the y-axis or the x-axis… Or maybe you might even want to change the colour of the graph! You can customise all of that! Here are some ideas. # Assign color “grey” to the object barfill (which we will use below to change the colour of the bars). barfill &lt;- &quot;red&quot; # Assign color “black” to the object barlines (which we will use below to change the colour of the barlines). barlines &lt;- &quot;black&quot; # Specify the data frame and the variables to plot. ggplot(swls2019_only, aes(x = swls2019_avg)) + # Specify the type of plot and binwidth. geom_histogram(binwidth = 0.5, # Specify the border of the bars. color = barlines, # Specify the color of the bar. fill = barfill) + # Label the x-axis. scale_x_continuous(name = &quot;2019 Satisfaction With Life Scores&quot;, # Force the graph to start at x = 0 expand = c(0, 0), # Force the graph to end at x = 7 limits = c(0, 7)) + # Label the y-axis. scale_y_continuous(name = &quot;Frequency&quot;, # Force the graph to start at y = 0 expand = c(0, 0), # No maximum limit to y (hence, NA) limits = c(0, NA)) + # Give the histogram a title. ggtitle(&quot;Histogram of SWLS2019&quot;) ## Warning: Removed 2 rows containing missing values (`geom_bar()`). Note that when you set limits on the graph, it throws up a warning: Warning: Removed 2 rows containing missing values (geom_bar()). This is a known issue, but is apparently too complex to resolve (see: https://github.com/tidyverse/ggplot2/issues/4083). You may safely ignore it if your limits are beyond the minimum and maximum values of your axes. For example, suppose your minimum value for the x-axis is 1 and your maximum value is 7. If you set the limits to 0 and 8, it should comprise all values in your dataset. You can find the minimum and maximum values using the summarise() function, or simply use max() or min(). 4.5.4 Scatterplot So far, we’ve been focusing on single variables (e.g., gender and swls2019_avg). What if we’re interested in the relationship between two continuous variables? Here is where we might want to plot a scatterplot! A scatterplot is a graph of pairs of values for each subject or individual. Each individual provides two observations, one for each variable. One of the variables will be plotted along the x-axis and the other along the y-axis. So, suppose we’re interested in plotting the relationship between two items from the SWLS2019 dataset: swls2019_1 and swls2019_2. The reasoning goes something like this: Both items supposedly measure satisfaction with life. So, if a participant scores higher on one item than another participant, they should also score higher on the other item. Let’s plot the scatterplot with the code below! swls2019_only %&gt;% ggplot(.) + geom_point(aes(x = swls2019_1, y = swls2019_2)) + # A scatterplot is a plot of points on a graph. So we use geom_point. labs(x = &quot;swls2019_1: In most ways my life is close to my ideal&quot;, y = &quot;swls2019_2: The conditions of my life are excellent&quot;) # labs() is another way to add labels. You can also add titles using the labs() function. From the scatterplot, we see that indeed, as swls2019_1 increases, swls2019_2 increases. Like the histogram, there are many different customizations beyond the basics I’ve shown you here. You can refer to this website for more: https://t-redactyl.io/blog/2016/02/creating-plots-in-r-using-ggplot2-part-5-scatterplots.html. 4.5.5 Last Words I’ve only just scratched the surface of plots in this tutorial. For more, visit here: https://t-redactyl.io/tag/r-graphing-tutorials.html. Or here: https://r4ds.had.co.nz/data-visualisation.html. And here’s a link to the ggplot2 cheatsheet: https://posit.co/wp-content/uploads/2022/10/data-visualization-1.pdf. Now that you’ve gotten to this point, I think you’re ready to do your second assignment! Proceed to the next section! "],["tha2.html", "5 Assignment 2 5.1 Due Date: 26-01-2023 5.2 Instructions 5.3 Legend", " 5 Assignment 2 5.1 Due Date: 26-01-2023 5.2 Instructions Download the data file here: SWB.csv. Open up a new script file in RStudio using Ctrl/Cmd + Shift + N. Set working directory using setwd(). Load tidyverse using library(). Read in the data file SWB.csv using read_csv() or read.csv(). Examine the dataset with glimpse() or View() or `str(). Check that you have 343 rows and 23 columns. Convert marital_status and have_children from integer to factor using factor(). Add value labels to the factors. See the legend below to see how each variable is coded. Use glimpse() or str() to check that the variables are indeed converted to factors. Create a subset of the dataset of only married parents (i.e., married people who have children). Further subset the dataset such that only the variables swls2021_1, swls2021_2, swls2021_3, swls2021_4, and swls2021_5 are in the dataset. You should have 68 rows and 5 columns in this subset. Using this subset, compute the average of swls2021_1, swls2021_2, swls2021_3, swls2021_4, and swls2021_5 for each person. Call this variable swls2021_avg. Create a histogram for swls2021_avg. Just play around with the different functions! Change the bar fill color, change the range of the x-axis, make the background white, etc. (I just want you to explore and have fun!) Using this subset, get the following summary statistics for swls2021_avg: maximum, minimum, mean, and sd. Check that the maximum is 5.4, the minimum is 2.6, the mean is 4.18, and the sd is 0.707. Find out the number of married parents who have ‘swls2021_avg’ greater than or equal to 4.18. (And no, I’m not asking you to count by hand.) Check that the number is 36. For each step above, put in comments using the # sign so that you know what was done. (e.g., # set working directory, # load packages) When you’re done with the above, copy and paste your R script into a word document. Submit the word document in the eLearn Assignment for 1 point. Note. Answers will be released on eLearn the day after this assignment is due. 5.3 Legend Variable Name Variable Label Value Label pin participant identification number gender gender 0 = male, 1 = female marital_status marital status 1 = married, 2 = divorced, 3 = widowed have_children parental status 0 = no children, 1 = have children mvs_1 My life would be better if I own certain things I don’t have. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_2 The things I own say a lot about how well I’m doing. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_3 I’d be happier if I could afford to buy more things. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_4 It bothers me that I can’t afford to buy things I’d like. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_5 Buying things gives me a lot of pleasure. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_6 I admire people who own expensive homes, cars, clothes. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_7 I like to own things that impress people. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_8 I like a lot of luxury in my life. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_9 I try to keep my life simple, as far as possessions are concerned. (R) 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree swls2019_1 In most ways my life is close to my ideal. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2019_2 The conditions of my life are excellent. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2019_3 I am satisfied with my life. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2019_4 So far I have gotten the important things I want in life. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2019_5 In most ways my life is close to my ideal. (2019) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_1 In most ways my life is close to my ideal. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_2 The conditions of my life are excellent. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_3 I am satisfied with my life. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_4 So far I have gotten the important things I want in life. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree swls2021_5 In most ways my life is close to my ideal. (2021) 1 = strongly disagree, 2 = disagree, 3 = slightly disagree, 4 = neither disagree nor agree, 5 = slightly agree, 6 = agree, 7 = strongly agree "],["scale.html", "6 Multi-Item Measures 6.1 Overview 6.2 Dataset 6.3 Checking the pattern of responses: Correlation coefficient 6.4 Reliability analysis: Cronbach’s alpha 6.5 Compute the average score for the scale", " 6 Multi-Item Measures 6.1 Overview This section guides you through the steps to deal with multi-item measures. Typically, for constructs that are measured (e.g., manipulation check items and/or dependent variables), we use several items to assess the construct. Because each item is supposed to measure the same construct, instead of looking at each item separately, it is more efficient to combine participants’ responses to these multiple items into a single score. This single score is then the variable that operationalizes our construct. However, because participants do not always respond to items in the way that researchers intend, we should first check that the pattern of responses is consistent with our expectations (i.e., check which items are positively / negatively related to each other). We also need to check whether the items have adequate reliability. Then, we can create an average score out of all the items of the scale. 6.2 Dataset We will use the hypothetical dataset that I introduced in the previous section. If you do not have a copy of it, please download the dataset to follow along here: SWB.csv. For this tutorial, we will only focus on the items measuring materialism. In this hypothetical study, materialism is measured with 9 items from the Materialism Values Survey (i.e., mvs_1–mvs_9). mvs_1–mvs_8 are positively keyed items, meaning that higher scores should indicate greater endorsement of materialistic values. mvs_9 is a reverse (or negatively) keyed item, meaning that higher scores on mvs_9 should indicate lesser endorsement of materialistic values. We want to combine all the 9 items into one overall measure of materialism. The specific wording of each item in the MVS is listed below. Legend Variable Name Variable Label Value Label pin participant identification number mvs_1 My life would be better if I own certain things I don’t have. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_2 The things I own say a lot about how well I’m doing. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_3 I’d be happier if I could afford to buy more things. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_4 It bothers me that I can’t afford to buy things I’d like. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_5 Buying things gives me a lot of pleasure. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_6 I admire people who own expensive homes, cars, clothes. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_7 I like to own things that impress people. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_8 I like a lot of luxury in my life. 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree mvs_9 I try to keep my life simple, as far as possessions are concerned. (R) 1 = strongly disagree, 2 = disagree, 3 = neither disagree nor agree, 4 = agree, 5 = strongly agree Let’s start by reading in the dataset, then creating a subset of the dataset. We will keep mvs_1 - mvs_9 but will also keep the participant identification number so that if there are any issues with the responses (e.g., if there is missing data), we know which participant that issue came from. s # Load package library(tidyverse) # Read in the data data &lt;- read_csv(&quot;SWB.csv&quot;) # Create subset with the required variables and call it MVS MVS &lt;- data %&gt;% select(pin, mvs_1:mvs_9) # Check that you&#39;ve done the subset correctly glimpse(MVS) ## Rows: 343 ## Columns: 10 ## $ pin &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1… ## $ mvs_1 &lt;dbl&gt; 4, 4, 5, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 3, 3, 4, 3, 3, 4, 4… ## $ mvs_2 &lt;dbl&gt; 3, 3, 4, 3, 2, 4, 3, 3, 4, 3, 2, 4, 1, 3, 2, 3, 2, 4, 3, 2, 4, 3… ## $ mvs_3 &lt;dbl&gt; 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 2, 2, 3, 4, 4, 5, 3, 3, 4, 4… ## $ mvs_4 &lt;dbl&gt; 3, 3, 3, 2, 2, 5, 4, 4, 3, 4, 4, 4, 2, 2, 4, 3, 3, 4, 4, 4, 5, 4… ## $ mvs_5 &lt;dbl&gt; 3, 3, 4, 3, 3, 4, 3, 3, 4, 2, 2, 3, 3, 3, 4, 4, 4, 5, 3, 3, 4, 4… ## $ mvs_6 &lt;dbl&gt; 4, 4, 5, 2, 2, 3, 4, 4, 5, 2, 2, 3, 3, 3, 4, 2, 2, 3, 4, 4, 5, 4… ## $ mvs_7 &lt;dbl&gt; 3, 2, 4, 2, 3, 3, 3, 3, 4, 3, 1, 4, 4, 1, 5, 1, 3, 2, 3, 3, 4, 3… ## $ mvs_8 &lt;dbl&gt; 4, 4, 5, 4, 4, 5, 3, 3, 4, 3, 3, 4, 2, 2, 3, 3, 3, 4, 4, 4, 5, 3… ## $ mvs_9 &lt;dbl&gt; 2, 2, 1, 3, 3, 2, 3, 3, 2, 4, 4, 3, 4, 4, 3, 3, 3, 2, 3, 3, 2, 3… 6.3 Checking the pattern of responses: Correlation coefficient The correlation coefficient tells us if two variables are linearly related. In general, there are two directions, positive and negative. When two variables increase or decrease in the same direction (e.g., when one increases, the other also increases; when one decreases, the other also decreases), we call this a positive linear relationship. The correlation coefficient will be a positive number. When the two variables move in different directions (e.g., when one increases, the other decreases and vice versa), we call this a negative linear relationship. The correlation coefficient will be a negative number. The correlation coefficient always has a minimum value of -1 (i.e., variables are perfectly negatively correlated) and a maximum value of 1 (i.e., variables are perfectly positively correlated). Because all the items of the Materialism Values Survey are supposed to measure the same construct, i.e., materialism, we expect positive-keyed items to correlate positively with each other, and reverse-keyed items to correlate negatively with positive-keyed items. So, we should expect all items to be positively related to each other except for mvs_9. To confirm our expectations, we need the correlations between each pair of items in the Materialism Values Survey. cor(MVS) # cor() tells R to calculate the correlations for each pair of items/variables. ## pin mvs_1 mvs_2 mvs_3 mvs_4 mvs_5 ## pin 1.000000000 0.01820791 0.00261561 0.0190207 -0.004592464 0.02088333 ## mvs_1 0.018207909 1.00000000 0.43763755 0.3899635 0.350306014 0.56608026 ## mvs_2 0.002615610 0.43763755 1.00000000 0.3956159 0.342974781 0.43869719 ## mvs_3 0.019020703 0.38996352 0.39561590 1.0000000 0.358897021 0.50948105 ## mvs_4 -0.004592464 0.35030601 0.34297478 0.3588970 1.000000000 0.26055546 ## mvs_5 0.020883333 0.56608026 0.43869719 0.5094811 0.260555462 1.00000000 ## mvs_6 0.029931812 0.67775570 0.28114358 0.3502713 0.455624190 0.44042258 ## mvs_7 0.014597497 0.42771247 0.29644060 0.4019504 0.494644383 0.38935168 ## mvs_8 0.012333886 0.57560443 0.39774601 0.2562786 0.361006990 0.62365310 ## mvs_9 -0.031136263 -0.75002163 -0.43323415 -0.6384993 -0.384562433 -0.53922937 ## mvs_6 mvs_7 mvs_8 mvs_9 ## pin 0.02993181 0.0145975 0.01233389 -0.03113626 ## mvs_1 0.67775570 0.4277125 0.57560443 -0.75002163 ## mvs_2 0.28114358 0.2964406 0.39774601 -0.43323415 ## mvs_3 0.35027129 0.4019504 0.25627862 -0.63849929 ## mvs_4 0.45562419 0.4946444 0.36100699 -0.38456243 ## mvs_5 0.44042258 0.3893517 0.62365310 -0.53922937 ## mvs_6 1.00000000 0.6200303 0.56460779 -0.74614447 ## mvs_7 0.62003030 1.0000000 0.40459133 -0.55145900 ## mvs_8 0.56460779 0.4045913 1.00000000 -0.64079832 ## mvs_9 -0.74614447 -0.5514590 -0.64079832 1.00000000 (Personally, I think the output is much easier to read if you coerce it into a dataframe with this code: cor.output &lt;- as.data.frame(cor(MVS)) and then View(cor.output). But that’s just for readability–there is no difference in the actual result.) Each row by column cell in the output shows the correlation between the row item and the column item (e.g., item mvs_1 and item mvs_2 have a correlation of .4525015). From the output, we see that positive-keyed items correlate positively with each other (i.e., the correlations are positive for all pairs of positive-keyed items). We also see that positive-keyed items correlate negatively with the reverse-keyed item. The correlations between MVS09 (in the rightmost column) and each of the other items are negative. These results indicate that participants are responding to the items as we expect. To be honest, I much prefer to first reverse code all the reverse keyed items before getting the correlation coefficients. That way, it’s much easier to spot a problem—the moment I see a negative sign, it’s a problem. So, let’s do that instead. The simple formula to use to reverse code data is this: (max possible value on likert scale + min possible value on likert scale) - observation. If you refer to the legend, you’ll see that the maximum possible value is 5 and the minimum possible value is 1. MVS &lt;- MVS %&gt;% mutate(mvs_9r = 5+1-mvs_9) View(MVS) # Check that you’ve correctly recoded mvs_9. That is, a 1 on mvs_9 should be a 5 on mvs_9r, and so on. Note. Notice that I labelled my recoded variable as mvs_9r (where r stands for recoded). Some people might choose to replace the variable instead of giving the recoded variable a new name. So they might code do the following: mutate(mvs_9 = 5+1-mvs_9). Notice the r is missing? I strongly recommend against this as it might confuse you later on–you cannot be sure whether you have recoded the variable or not and might have to keep checking back on the code. If all is okay, drop mvs_9 by using select() and then look at the correlation matrix. # Drop mvs_9. MVS &lt;- MVS %&gt;% select(pin, mvs_1:mvs_8, mvs_9r) # Check the correlation matrix cor(MVS) ## pin mvs_1 mvs_2 mvs_3 mvs_4 mvs_5 ## pin 1.000000000 0.01820791 0.00261561 0.0190207 -0.004592464 0.02088333 ## mvs_1 0.018207909 1.00000000 0.43763755 0.3899635 0.350306014 0.56608026 ## mvs_2 0.002615610 0.43763755 1.00000000 0.3956159 0.342974781 0.43869719 ## mvs_3 0.019020703 0.38996352 0.39561590 1.0000000 0.358897021 0.50948105 ## mvs_4 -0.004592464 0.35030601 0.34297478 0.3588970 1.000000000 0.26055546 ## mvs_5 0.020883333 0.56608026 0.43869719 0.5094811 0.260555462 1.00000000 ## mvs_6 0.029931812 0.67775570 0.28114358 0.3502713 0.455624190 0.44042258 ## mvs_7 0.014597497 0.42771247 0.29644060 0.4019504 0.494644383 0.38935168 ## mvs_8 0.012333886 0.57560443 0.39774601 0.2562786 0.361006990 0.62365310 ## mvs_9r 0.031136263 0.75002163 0.43323415 0.6384993 0.384562433 0.53922937 ## mvs_6 mvs_7 mvs_8 mvs_9r ## pin 0.02993181 0.0145975 0.01233389 0.03113626 ## mvs_1 0.67775570 0.4277125 0.57560443 0.75002163 ## mvs_2 0.28114358 0.2964406 0.39774601 0.43323415 ## mvs_3 0.35027129 0.4019504 0.25627862 0.63849929 ## mvs_4 0.45562419 0.4946444 0.36100699 0.38456243 ## mvs_5 0.44042258 0.3893517 0.62365310 0.53922937 ## mvs_6 1.00000000 0.6200303 0.56460779 0.74614447 ## mvs_7 0.62003030 1.0000000 0.40459133 0.55145900 ## mvs_8 0.56460779 0.4045913 1.00000000 0.64079832 ## mvs_9r 0.74614447 0.5514590 0.64079832 1.00000000 Now that we recoded mvs_9 into mvs_9r, you can see, all correlation coefficients here are positive. So, all is good! Let’s move on to the next bit. 6.4 Reliability analysis: Cronbach’s alpha Before averaging the items to get an overall MVS score, we must demonstrate that the items have adequate reliability. Cronbach’s alpha is the most common measure of internal consistency reliability. It’s a number that ranges from 0 to 1 and indicates how well the items on the scale measure the same construct (in this case, materialism). An alpha of .70 is accepted by many researchers as adequate reliability. However, for certain purposes, an alpha of .60 to .70 can be accepted if justified (e.g., research is new and exploratory or focused on theory or items measure different facets of the construct). If reliability is too low, however, this might mean the responses were too inconsistent across items. Then it might not make sense to average them together. This would be an important limitation to discuss in your paper. We will use the alpha() function in the psych package to conduct the reliability analysis. At this point, it’s worth noting that this function is used on the data frame with the reverse-keyed items all reverse coded already. So, if you haven’t reverse-coded mvs_9 yet, do so before continuing. It should also be noted that ggplot2 also has an alpha function. So R will be confused as to which package you want to use. You can specify the package like this: package::function(). psych::alpha(MVS) # tell R we want the Cronbach’s alpha for all the items in MVS. Note. Before you use the alpha() function in the psych package, remember to install the package! If you don’t have it installed, RStudio will give you a warning at the top of the script editor. Click on the warning to install the package. Notice that we do not need to load the package using library(psych). psych::alpha() temporarily loads the package (just for that function). If you want to use other functions in the psych package, then you’ll probably want to load the package. ## ## Reliability analysis ## Call: psych::alpha(x = MVS) ## ## raw_alpha std.alpha G6(smc) average_r S/N ase mean sd median_r ## 0.0061 0.86 0.89 0.38 6 0.0073 20 9.9 0.4 ## ## 95% confidence boundaries ## lower alpha upper ## Feldt -0.16 0.01 0.16 ## Duhachek -0.01 0.01 0.02 ## ## Reliability if an item is dropped: ## raw_alpha std.alpha G6(smc) average_r S/N alpha se var.r med.r ## pin 0.8800 0.89 0.91 0.47 7.8 0.0098 0.018 0.44 ## mvs_1 0.0050 0.83 0.87 0.35 4.9 0.0066 0.046 0.39 ## mvs_2 0.0055 0.85 0.89 0.39 5.6 0.0067 0.054 0.40 ## mvs_3 0.0052 0.84 0.87 0.38 5.4 0.0067 0.053 0.42 ## mvs_4 0.0057 0.85 0.88 0.39 5.7 0.0067 0.054 0.42 ## mvs_5 0.0051 0.84 0.87 0.36 5.2 0.0067 0.051 0.39 ## mvs_6 0.0049 0.83 0.86 0.35 4.9 0.0066 0.045 0.39 ## mvs_7 0.0050 0.84 0.88 0.37 5.3 0.0065 0.052 0.39 ## mvs_8 0.0053 0.84 0.87 0.36 5.1 0.0067 0.049 0.39 ## mvs_9r 0.0049 0.82 0.85 0.34 4.6 0.0066 0.041 0.39 ## ## Item statistics ## n raw.r std.r r.cor r.drop mean sd ## pin 343 0.998 0.17 0.023 0.021 172.0 99.16 ## mvs_1 343 0.066 0.78 0.777 0.057 3.4 0.92 ## mvs_2 343 0.041 0.61 0.536 0.030 2.9 1.08 ## mvs_3 343 0.059 0.65 0.633 0.050 3.5 0.91 ## mvs_4 343 0.034 0.61 0.541 0.024 3.3 1.00 ## mvs_5 343 0.065 0.72 0.702 0.056 3.5 0.89 ## mvs_6 343 0.078 0.78 0.778 0.069 3.7 0.89 ## mvs_7 343 0.059 0.70 0.652 0.047 3.1 1.15 ## mvs_8 343 0.057 0.73 0.716 0.048 3.6 0.85 ## mvs_9r 343 0.084 0.86 0.888 0.076 3.6 0.79 ## ## Non missing response frequency for each item ## 1 2 3 4 5 miss ## mvs_1 0.00 0.19 0.34 0.35 0.11 0 ## mvs_2 0.10 0.25 0.34 0.24 0.07 0 ## mvs_3 0.00 0.15 0.31 0.40 0.14 0 ## mvs_4 0.00 0.28 0.28 0.32 0.12 0 ## mvs_5 0.00 0.15 0.35 0.38 0.12 0 ## mvs_6 0.00 0.11 0.26 0.45 0.17 0 ## mvs_7 0.11 0.17 0.35 0.25 0.12 0 ## mvs_8 0.00 0.10 0.33 0.43 0.14 0 ## mvs_9r 0.00 0.06 0.36 0.44 0.13 0 The Reliability analysis section of the output tells us that the Cronbach’s alpha is .88 (raw_alpha). The last two lines tell us that the 95% confidence interval surrounding the Cronbach’s alpha is 95% CI [.85, .92]. That is, we can be 95% confident that this interval contains the population Cronbach’s alpha. We can ignore the other parts in this section as they are not relevant and look at the next section. The Reliability if an item is dropped section is especially helpful if we are looking at a scale that we have developed (i.e., NOT an established, well-validated scale that has been published), and are considering which items to exclude from our final scale. The table’s second column, raw_alpha, tells you what the Cronbach’s alpha would be if we re-ran the Reliability Analysis excluding that item. For example, if we computed the reliability without mvs_1 (first row), the Cronbach’s alpha would drop from .88 (from the Reliability analysis section) to .86. This means that the scale becomes less reliable when we remove mvs_1. So, we want to keep this item in our final scale. If deleting an item increases the overall Cronbach’s alpha (in this case, if the raw_alpha is larger than .88), then it means that the scale becomes more reliable when we remove the item. So, we would probably exclude the item from our final scale. In that case, re-analyse the data excluding that item. Repeat this process until there are no more items with a raw_alpha value greater than the Cronbach’s alpha for the overall scale. Take note of which items you excluded because you will need to exclude them in the next step. If the scale is obtained from a published source (as the MVS is), we do NOT exclude items. This is because we want to be able to compare our results with previous research that has used the same scale (i.e., with all the items). Excluding items means our results will not be directly comparable anymore. However, the Reliability if an item is dropped table is still helpful because it tells us if each item is contributing to the overall scale in the way we expect. If the items are not working in the way we expect, this would be an important limitation to discuss in the paper. We will ignore the Item statistics section and go straight to the section on Non missing response frequency for each item. This is a relative frequency table for all the items in the scale. The most important thing to note is whether there are any missing data for the items (see the column miss). In this case, there were no missing data. So hooray! 6.5 Compute the average score for the scale Now that we’re sufficiently satisfied with the reliability of the scale, let’s compute the average score. MVS &lt;- MVS %&gt;% mutate(MVSavg = rowMeans(across(c(mvs_1:mvs_8, mvs_9r)))) # calculate the average across the 9 items and call the average MVSavg You might want to check if MVSavg is correctly calculated. Go to View(MVS) and manually calculate the average of mvs_1 to mvs9r for participant 1. You should get 3.44 (to 2 d,p,). Congratulations on completing this tutorial! You’re now ready to do your third assignment! Proceed to the next section! "],["tha3.html", "7 Assignment 3 7.1 Due Date: 02-02-2023 7.2 Instructions 7.3 Legend", " 7 Assignment 3 7.1 Due Date: 02-02-2023 7.2 Instructions Download the data file here: WVS2012 Singapore BFI10 Data.csv.This dataset contains the responses of 1972 Singaporean participants to the 10-item Big Five Inventory (BFI10) in the 2012 World Values Survey. The BFI10 uses 2 items to measure each personality trait: extraversion, agreeableness, conscientiousness, openness to experience, and neuroticism. One item is positively-keyed and the other is reverse-keyed (R). See the legend below for more information. Open up a new script file in RStudio. Set working directory using setwd(). Load tidyverse and psych packages using library(). Read in the data file WVS2012 Singapore BFI10 Data.csv using read_csv() or read.csv(). Examine the dataset with glimpse() or View() or str(). Check that you have 1972 rows and 10 columns. Create a subset of the data by removing all participants who had negative values for any of the BFI10 items (e.g., -5, -2). (Hint: Use the filter_all() and all_vars() functions from the dplyr package. You’ll need to read up a bit to figure out how that works.) Reverse-code all the reverse-keyed items (V160A, V160C, V160D, V160E, V160G). Get the correlation coefficient for each pair of items for the same personality trait. Check that your answer matches mine: r = 0.1177 (extraversion), r = 0.0636 (agreeableness), r = 0.0921 (conscientiousness), r = 0.0478 (neuroticism), and r = -0.2959 (openness to experience). At this point, you should be surprised that openness to experience is negatively related, especially because we had actually re-coded the reverse-keyed items! Get the Cronbach’s alpha for each pair of items for the same personality trait. Check that your answer matches mine: α = 0.21 (extraversion), α = 0.12 (agreeableness), α = 0.17 (conscientiousness), α = 0.09 (neuroticism), and α = ERROR because items were negatively correlated (openness to experience). This suggests that the BFI10 has low reliability for the Singapore data. This mirrors findings elsewhere which suggest that the BFI10 has low reliability for non WEIRD (Western, Educated, Industrial, Rich, and Democratic) countries (https://renebekkers.wordpress.com/2017/03/21/hunting-game-targeting-the-big-five/). For each step above, put in comments using the # sign so that you know what was done. (e.g., # set working directory, # load packages) When you’re done with the above, copy and paste your R script into a word document. Submit the word document in the eLearn Assignment for 1 point. Note. Answers will be released on eLearn the day after this assignment is due. 7.3 Legend Variable Name Variable Label Construct Value Label V160A I see myself as someone who: is reserved Extraversion (R) -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly V160B I see myself as someone who: is generally trusting Agreeableness -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly V160C I see myself as someone who: tends to be lazy Conscientiousness (R) -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly V160D I see myself as someone who: is relaxed, handles stress well Neuroticism (R) -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly V160E I see myself as someone who: has few artistic interests Openness to experience (R) -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly V160F I see myself as someone who: is outgoing, sociable Extraversion -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly V160G I see myself as someone who: tends to find fault with others Agreeableness (R) -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly V160H I see myself as someone who: does a thorough job Conscientiousness -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly V160I I see myself as someone who: gets nervous easily Neuroticism -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly V160J I see myself as someone who: has an active imagination Openness to experience -5 = Missing, Unknown; -4 = Not asked in survey; -3 = Not applicable; -2 = No answer; -1 = Don’t know; 1 = Disagree strongly; 2 = Disagree a little; 3 = Neither agree nor disagree; 4 = Agree a little; 5 = Agree strongly "],["hypotest.html", "8 Hypothesis Testing 8.1 Overview 8.2 Load packages and dataset 8.3 One-Sample T Test 8.4 Correlated Groups T Test 8.5 Independent Groups T Test 8.6 One-Way Between-Subjects ANOVA 8.7 Two-Way Between-Subjects ANOVA 8.8 Correlation 8.9 Regression", " 8 Hypothesis Testing 8.1 Overview This section guides you through the steps to conduct the various hypothesis tests we cover in class. This only serves as an overview for students who are interested to read ahead. I will go through the hypothesis tests in more detail in class. We will use the hypothetical dataset that I introduced in the previous section. Please download the dataset to follow along here: SWB.csv. 8.2 Load packages and dataset # Load packages library(tidyverse) # Load dataset data &lt;- read_csv(&quot;SWB.csv&quot;) 8.3 One-Sample T Test We use a one-sample t test when we want to compare the data from one group to some hypothesized mean. So, let’s say we’re interested to know whether on average, in 2019, people were more satisfied with their lives than the neutral value of 4. (In this data set, the satisfaction with life items were measured on a 7-point scale, where 4 is the neutral point.) # Calculate the average satisfaction with life score in 2019 for each participant data &lt;- data %&gt;% mutate(swls2019_avg = rowMeans(across(c(swls2019_1:swls2019_5)))) # Conduct the one-sample t test to compare the satisfaction with life score in 2019 against the neutral point of 4. # &quot;two-sided&quot; means we&#39;re conducting a two-tailed test # mu = 4 refers to the hypothesized value we&#39;re comparing to # paired = FALSE means that each observation comes from different individuals (i.e., they are not &quot;paired&quot;) # conf.level = 0.95 means we want the 95% confidence level. Usually, if we use alpha = .05, then the confidence level is 0.95. t.test(data$swls2019_avg, alternative = c(&quot;two.sided&quot;), mu = 4, paired = FALSE, conf.level = 0.95) ## ## One Sample t-test ## ## data: data$swls2019_avg ## t = 8.5309, df = 342, p-value = 4.775e-16 ## alternative hypothesis: true mean is not equal to 4 ## 95 percent confidence interval: ## 4.271882 4.434823 ## sample estimates: ## mean of x ## 4.353353 The results indicate that the average of swls2019_avg is 4.35. When we compare 4.35 to the neutral point of 4, the resulting t value is 8.53. With degrees of freedom 342, the p value is very small, at 4.77e-16. 4.77e-16 is scientific notation expressing 4.77 x 10^-16. So 4.77e-16 would be 0.000000000000000477. The 95% confidence interval is [4.27, 4.43] which is interpreted as follows: We are 95% confident that the true 2019 satisfaction with life score is between 4.27 and 4.43. 8.4 Correlated Groups T Test Suppose we want to know whether people’s satisfaction with life scores changed from 2019 to 2021. To do this, we conduct a correlated groups t test. # Calculate the average satisfaction with life score in 2021 for each participant. # If you did not calculate the average satisfaction with life score in 2019 earlier, you might want to do that here also. data &lt;- data %&gt;% mutate(swls2021_avg = rowMeans(across(c(swls2021_1:swls2021_5)))) # Conduct the correlated groups t test to compare the satisfaction with life score in 2019 and that in 2021 to see if there is any change over the two years. # &quot;two-sided&quot; means we&#39;re conducting a two-tailed test # mu = 0 means we&#39;re comparing the difference against the value of 0. # paired = TRUE means that each individual offered pairs of observations (i.e., swls2019_avg and swls2021_avg) # conf.level = 0.95 means we want the 95% confidence level. Usually, if we use alpha = .05, then the confidence level is 0.95. t.test(data$swls2019_avg, data$swls2021_avg, alternative = c(&quot;two.sided&quot;), mu = 0, paired = TRUE, conf.level = 0.95) ## ## Paired t-test ## ## data: data$swls2019_avg and data$swls2021_avg ## t = 27.83, df = 342, p-value &lt; 2.2e-16 ## alternative hypothesis: true mean difference is not equal to 0 ## 95 percent confidence interval: ## 0.4649322 0.5356509 ## sample estimates: ## mean difference ## 0.5002915 The results indicate that the average of the difference between swls2019_avg and swls2021_avg is 0.50. When we compare this difference against 0, the resulting t value is 27.83. With degrees of freedom 342, the p value is very small, at 2.2e-16. The 95% confidence interval is [0.46, 0.54] which is interpreted as follows: We are 95% confident that the true difference between the 2019 and 2021 satisfaction with life scores is between 0.46 and 0.54. 8.5 Independent Groups T Test Suppose we want to know whether men and women differ in satisfaction with life in 2019. To do this, we conduct a independent groups t test. # First, we need to convert gender into a factor data$gender &lt;- factor(data$gender, levels = c(0, 1), labels = c(&quot;male&quot;, &quot;female&quot;)) # Next, we conduct the independent groups t test # Notice that this t.test code takes the form of DV ~ IV # &quot;two-sided&quot; means we&#39;re conducting a two-tailed test # mu = 0 means we&#39;re comparing the difference against the value of 0. # var.equal = TRUE means that we&#39;re assuming homogeneity of variance is met (if homogeneity of variance is violated, use var.equal = FALSE and R will conduct Welch corrections) # conf.level = 0.95 means we want the 95% confidence level. Usually, if we use alpha = .05, then the confidence level is 0.95. t.test(data$swls2019_avg ~ data$gender, alternative = c(&quot;two.sided&quot;), mu = 0, var.equal = TRUE, conf.level = 0.95) ## ## Two Sample t-test ## ## data: data$swls2019_avg by data$gender ## t = -6.8986, df = 341, p-value = 2.564e-11 ## alternative hypothesis: true difference in means between group male and group female is not equal to 0 ## 95 percent confidence interval: ## -0.6891325 -0.3833437 ## sample estimates: ## mean in group male mean in group female ## 4.079762 4.616000 The results indicate that the average satisfaction with life score for those who identify as male is 4.08 and 4.62 for those who identify as female. When we compare the difference between the two genders against 0, the resulting t value is -6.90. With degrees of freedom 341, the p value is very small, at 2.564e-11. The 95% confidence interval is [-0.69, -0.38] which is interpreted as follows: We are 95% confident that the true difference in 2019 satisfaction with life score between males and females is between -0.69 and -0.38. Note. In calculating the t statistic, R took male - female (since 0 = male and 1 = female, and R takes the group with the smaller number and subtracts the group with the larger number) . Because males have a smaller 2019 SWLS than females, the t statistic is negative. However, if R had taken female - male, the t statistic would be positive. Whether it is positive or negative doesn’t matter so long as you know which group has a higher mean. 8.6 One-Way Between-Subjects ANOVA Suppose we want to know whether marital status affects subjective wellbeing. In essence, we might want to find out whether there is at least one mean difference between: a) married vs divorced, b) married vs widowed, c) divorced vs widowed. # Convert marital status into factor data$marital_status &lt;- factor(data$marital_status, levels = c(1, 2, 3), labels = c(&quot;married&quot;, &quot;divorced&quot;, &quot;widowed&quot;)) # Run the ANOVA # ANOVA is strange in that to view the results, you need to save it as an object first. results &lt;- data %&gt;% aov(data = ., swls2019_avg ~ marital_status) # you need to specify where the data is coming from. So, when you specify data = ., it&#39;s telling R that the data for analysis comes from the object data which is before the pipe operator, %&gt;%. # Look at the summary results summary(results) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## marital_status 2 10.78 5.392 9.624 8.6e-05 *** ## Residuals 340 190.47 0.560 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 There are two other ways to run the ANOVA. The results will be exactly the same. # Alternative 1 results &lt;- aov(data$swls2019_avg ~ data$marital_status) #Alternative 2 results &lt;- aov(data = data, swls2019_avg ~ marital_status) Because the ANOVA results are statistically significant, we might want to follow up with pairwise comparisons (Tukey’s HSD). To run this, we need the DescTools package. (Remember to install the package Before continuing.) # Load package library(DescTools) # Perform a posthoc test on the results using Tukey&#39;s HSD. Oh, and give me the 95% CI. PostHocTest(results, method = &quot;hsd&quot;, conf.level = .95) ## ## Posthoc multiple comparisons of means : Tukey HSD ## 95% family-wise confidence level ## ## $marital_status ## diff lwr.ci upr.ci pval ## divorced-married -0.4233423 -0.65472757 -0.1919569 6.4e-05 *** ## widowed-married -0.2802413 -0.51321151 -0.0472710 0.0136 * ## widowed-divorced 0.1431010 -0.09184204 0.3780440 0.3247 ## ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 If you want other posthoc tests, you can change the method portion. Type ?PostHocTest into the console to find out more about the different post hoc tests available to you. 8.7 Two-Way Between-Subjects ANOVA Suppose you want to know whether the difference in satisfaction with life scores between male and female depends on whether they have children. To find out, you will need to conduct a two-way between-subjects ANOVA. You’ll need the car package to run the ANOVA. # Load package library(car) # Change have_children into a factor data$have_children &lt;- factor(data$have_children, levels = c(0, 1), labels = c(&quot;no children&quot;, &quot;have children&quot;)) # Change contrasts settings when estimating Type-3 sum of squares options(contrasts = c(&#39;contr.sum&#39;, &#39;contr.poly&#39;)) # Set up the model being tested and store the model to [mod1] # The model has the following format: DV ~ IV1 + IV2 + IV1*IV2 mod1 &lt;- lm(swls2019_avg ~ gender + have_children + gender*have_children, data = data) # Conduct Two-Way ANOVA and get the ANOVA summary table # type = &quot;3&quot; refers to Type 3 sum of squares. For this class, we will use Type 3 sum of squares. Anova(mod1, type = &quot;3&quot;) ## Anova Table (Type III tests) ## ## Response: swls2019_avg ## Sum Sq Df F value Pr(&gt;F) ## (Intercept) 6366.9 1 13955.5140 &lt; 2.2e-16 *** ## gender 19.8 1 43.4025 1.703e-10 *** ## have_children 18.6 1 40.7208 5.767e-10 *** ## gender:have_children 3.1 1 6.7787 0.009631 ** ## Residuals 154.7 339 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Because the interaction is statistically significant, we will conduct the simple effects analysis. This is essentially like conducting independent groups t tests (with some corrections). Since we want to find out whether the difference between male and female’s satisfaction with life scores depends on having children, the two tests we will conduct would be: 1) difference in the satisfaction with life scores of males and females who have children; 2) difference in the satisfaction with life scores of males and females who do not have children. To do the simple effects analyses, we need the emmeans package. # Load package library(emmeans) # first, let&#39;s look at a plot # Separate Lines: have_children, X axis: gender emmip(mod1, have_children ~ gender) # Next, we conduct the simple effects investigating 1) the effect of gender (difference between males and females) for those who have children, and 2) the effect of gender for those who do not have children. emmeans(mod1, pairwise ~ gender | have_children) # comparing the pair of conditions in gender for each level of have_children ## $emmeans ## have_children = no children: ## gender emmean SE df lower.CL upper.CL ## male 3.95 0.0704 339 3.82 4.09 ## female 4.25 0.0770 339 4.10 4.40 ## ## have_children = have children: ## gender emmean SE df lower.CL upper.CL ## male 4.23 0.0775 339 4.08 4.38 ## female 4.91 0.0682 339 4.77 5.04 ## ## Confidence level used: 0.95 ## ## $contrasts ## have_children = no children: ## contrast estimate SE df t.ratio p.value ## male - female -0.292 0.104 339 -2.803 0.0054 ## ## have_children = have children: ## contrast estimate SE df t.ratio p.value ## male - female -0.675 0.103 339 -6.534 &lt;.0001 Suppose, though, you were interested in looking at the effect of having children by gender. In other words, you’re interested in looking at the difference 1) between men with and men without children, and 2) between women with and women without children. In this case, you will swap the variables around. # First, let&#39;s look at a plot # Separate Lines: gender, X axis: have_children emmip(mod1, gender ~ have_children) # Next, we conduct the simple effects investigating 1) the effect of having children (difference between having children and not having children) for males, and 2) of having children (difference between having children and not having children) for females. emmeans(mod1, pairwise ~ have_children | gender) # comparing the pair of conditions in have_children for each level of gender ## $emmeans ## gender = male: ## have_children emmean SE df lower.CL upper.CL ## no children 3.95 0.0704 339 3.82 4.09 ## have children 4.23 0.0775 339 4.08 4.38 ## ## gender = female: ## have_children emmean SE df lower.CL upper.CL ## no children 4.25 0.0770 339 4.10 4.40 ## have children 4.91 0.0682 339 4.77 5.04 ## ## Confidence level used: 0.95 ## ## $contrasts ## gender = male: ## contrast estimate SE df t.ratio p.value ## no children - have children -0.277 0.105 339 -2.648 0.0085 ## ## gender = female: ## contrast estimate SE df t.ratio p.value ## no children - have children -0.659 0.103 339 -6.410 &lt;.0001 8.8 Correlation Suppose you want to find out whether people who have higher satisfaction with life scores in 2019 also have higher satisfaction with life scores in 2021. Here is where you will conduct a correlation. data &lt;- data %&gt;% mutate(swls2021_avg = rowMeans(across(c(swls2021_1:swls2021_5)))) cor.test(data$swls2019_avg, data$swls2021_avg) ## ## Pearson&#39;s product-moment correlation ## ## data: data$swls2019_avg and data$swls2021_avg ## t = 38.396, df = 341, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.8792002 0.9193515 ## sample estimates: ## cor ## 0.9011917 Alternatively, you can do the correlation test this way: # Alternative 1 cor.test(~ swls2019_avg + swls2021_avg, data = data) # Alternative 2 data %&gt;% cor.test(formula = ~ swls2019_avg + swls2021_avg, .) All ways would give you the same result. 8.9 Regression Suppose you want to predict swls2021_avg from swls2019_avg. Here, we might want to conduct linear regression. The simplest form of linear regression is called simple linear regression. It only has two variables: one predictor and one outcome. # Conduct regression # the model takes the form of Y ~ X (where Y = outcome, X = predictor) data %&gt;% lm(swls2021_avg ~ swls2019_avg, data = .) %&gt;% summary(.) ## ## Call: ## lm(formula = swls2021_avg ~ swls2019_avg, data = .) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.05665 -0.24833 -0.00666 0.19334 0.80165 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.40659 0.09114 4.461 1.11e-05 *** ## swls2019_avg 0.79168 0.02062 38.396 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2925 on 341 degrees of freedom ## Multiple R-squared: 0.8121, Adjusted R-squared: 0.8116 ## F-statistic: 1474 on 1 and 341 DF, p-value: &lt; 2.2e-16 Unfortunately, the summary doesn’t give us the confidence interval. To get that, we need to specify that we want the confidence interval with the confint() function. # To get the 95% confidence interval data %&gt;% lm(swls2021_avg ~ swls2019_avg, data = .) %&gt;% confint(.) ## 2.5 % 97.5 % ## (Intercept) 0.2273200 0.5858564 ## swls2019_avg 0.7511261 0.8322388 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
